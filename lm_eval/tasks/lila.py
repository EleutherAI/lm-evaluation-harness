"""
LILA: A Unified Benchmark for Mathematical Reasoning
https://aclanthology.org/2022.emnlp-main.392.pdf

Given a natural language problem specification x, the task is to generate
a program y that upon execution returns the correct answer to x. In the
evaluation harness, LILA has 48 tasks. Each task corresponds to a subset
in the HuggingFace dataset (https://huggingface.co/datasets/allenai/lila),
and is named `lila_{subset}`. 46 of the tasks correspond to either an
individual dataset (e.g. lila_GSM8k_structured) or a dataset partition
(e.g. lila_amps_algebra). The other two tasks are 'aggregate' tasks,
`lila_iid` and `lila_ood`, corresponding to the IID and OOD multitask splits
defined in the paper, respectively.

Homepage: https://github.com/allenai/lila
"""
import re
import timeout_decorator
from io import StringIO
from contextlib import redirect_stdout
from collections import Counter

from lm_eval.metrics import mean
from lm_eval.base import Task, rf


_CITATION = """
@inproceedings{mishra2022lila,
  author = {
    Swaroop Mishra 
      and Matthew Finlayson 
      and Pan Lu 
      and Leonard Tang 
      and Sean Welleck 
      and Chitta Baral 
      and Tanmay Rajpurohit 
      and Oyvind Tafjord 
      and Ashish Sabharwal 
      and Peter Clark 
      and Ashwin Kalyan},
  title = {Lila: A Unified Benchmark for Mathematical Reasoning},
  booktitle = {Proceedings of the 2022 Conference on Empirical Methods in Natural Language Processing (EMNLP)},
  year = {2022}
}
"""


class Lila(Task):
    VERSION = 0
    DATASET_PATH = "allenai/lila"
    DATASET_NAME = "iid"

    def has_training_docs(self):
        return True

    def has_validation_docs(self):
        return True

    def has_test_docs(self):
        return True

    def training_docs(self):
        if self.has_training_docs():
            if self._training_docs is None:
                self._training_docs = list(self.dataset["train"])
            return self._training_docs

    def validation_docs(self):
        if self.has_validation_docs():
            return self.dataset["dev"]

    def test_docs(self):
        if self.has_test_docs():
            return self.dataset["test"]

    def doc_to_text(self, doc):
        text = "Question: " + doc["input"] + "\n\n" + "Program:\n" + "```python\n"
        return text

    def doc_to_target(self, doc):
        target = doc["output_program"] + "\n```"
        return target

    def construct_requests(self, doc, ctx):
        """Uses RequestFactory to construct Requests and returns an iterable of
        Requests which will be sent to the LM.

        :param doc:
            The document as returned from training_docs, validation_docs, or
            test_docs.
        :param ctx: str
            The context string, generated by fewshot_context. This includes the natural
            language description, as well as the few shot examples, and the question
            part of the document for `doc`.
        """
        output = rf.greedy_until(ctx, "```")
        return output

    def process_results(self, doc, results):
        """Take a single document and the LM results and evaluates, returning a
        dict where keys are the names of submetrics and values are the values of
        the metric for that one document

        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param results:
            The results of the requests created in construct_requests.
        """
        program = self._parse_result(results[0])
        f1, exact_match, ran, exec_result = self.evaluate(
            program=program,
            gold_answer=doc['output_answer'],
            gold_program=doc['output_program'],
            dataset=doc['dataset']
        )
        results = {
            "f1": f1,
            "exact_match": exact_match,
            "ran": ran,
            "metadata": {
                "exec_result": exec_result,
                "program": program
            }
        }
        return results

    def aggregation(self):
        """
        :returns: {str: [metric_score] -> float}
            A dictionary where keys are the names of submetrics and values are
            functions that aggregate a list of metric scores
        """
        return {
            "f1": mean,
            "exact_match": mean,
            "ran": mean,
        }

    def higher_is_better(self):
        return {
            "f1": True,
            "exact_match": True,
            "ran": True
        }

    def evaluate(self, program, gold_answer, gold_program, dataset):
        # No execution for these datasets.
        skip_execution = False
        for name in {'APPS_structured', 'mbpp_structured', 'conala_structured'}:
            if name in dataset:
                skip_execution = True
        if skip_execution:
            # Set versions of the predicted program as predicted answer candidates.
            predicted_answers = self._versions(program)
            gold_answers = self._versions(gold_answer)
            ran = True
            exec_result = ''
        else:
            # Get the execution result.
            exec_result, ran, msg = self._run(program)

            # Set versions of the execution result as predicted answer candidates.
            predicted_answers = self._versions(exec_result)

            # Get additional gold answer candidates by executing the gold program.
            gold_answers = self._versions(gold_answer)
            gold_exec_result, gold_ran, _ = self._run(gold_program)
            if gold_ran:
                gold_answers.extend(self._versions(gold_exec_result))

        # Take the maximum metric value over all pairs of predicted and gold answers.
        f1 = self._metric_max_over_ground_truths(
            self._f1_score, predicted_answers, gold_answers
        )
        em = self._metric_max_over_ground_truths(
            self._em, predicted_answers, gold_answers
        )
        return f1, em, ran, exec_result

    def _parse_result(self, result):
        program = result.strip()
        return program

    def _versions(self, answer):
        return [
            self._parse_float(answer),     # parsed_float
            self._normalize_text(answer),  # normalized text
            answer,  # original
        ]

    def _run(self, program, timeout=1):
        ran = False
        msg = {}

        @timeout_decorator.timeout(timeout)
        def __run():
            f = StringIO()
            with redirect_stdout(f):
                exec(program)
                answer = f.getvalue().strip()
                return answer, True
        try:
            answer, ran = __run()
        except Exception as e:
            answer = 'FAILED'
            msg = {
                'type': str(type(e)),
                'exception': str(e)
            }
            ran = False
        return answer, ran, msg

    def _em(self, predicted, gold):
        return predicted == gold

    def _f1_score(self, prediction: str, ground_truth: str):
        def _normalize_answer(s):
            return str(s).strip()

        prediction_tokens = _normalize_answer(prediction).split()
        ground_truth_tokens = _normalize_answer(ground_truth).split()
        common = Counter(prediction_tokens) & Counter(ground_truth_tokens)
        num_same = sum(common.values())
        if num_same == 0:
            return 0
        precision = 1.0 * num_same / len(prediction_tokens)
        recall = 1.0 * num_same / len(ground_truth_tokens)
        f1 = (2 * precision * recall) / (precision + recall)
        return f1

    def _parse_float(self, text):
        """Converts `text` according to the following precedence:
            1. convert with `float()`
            2. find exactly one integer or float via regex
            3. return the original `text` string
        """
        text = text.strip().replace(',', '')
        try:
            answer = float(text)
            return answer
        except ValueError:
            rx = re.compile(r'(-?\d+\.?\d*)')
            matches = rx.findall(text)
            if len(matches) == 1:
                try:
                    answer = float(matches[0])
                    return answer
                except ValueError:
                    pass
        return text

    def _normalize_text(self, text):
        """Strip, lower text and remove extra whitespace."""
        def white_space_fix(text):
            return " ".join(text.split())
        def lower(text):
            return text.lower()
        return white_space_fix(lower(text.strip()))

    def _metric_max_over_ground_truths(self, metric_fn, predictions, ground_truths):
        scores = []
        for prediction in predictions:
            for ground_truth in ground_truths:
                score = metric_fn(prediction, ground_truth)
                scores.append(score)
        return max(scores)


class LilaOOD(Lila):
    DATASET_NAME = 'ood'

class LilaAddSub(Lila):
    DATASET_NAME = 'addsub'

class LilaAmpsAlgebra(Lila):
    DATASET_NAME = 'amps_algebra'

class LilaAmpsCalculus(Lila):
    DATASET_NAME = 'amps_calculus'

class LilaAmpsCountingAndStats(Lila):
    DATASET_NAME = 'amps_counting_and_stats'

class LilaAmpsGeometry(Lila):
    DATASET_NAME = 'amps_geometry'

class LilaAmpsLinearAlgebra(Lila):
    DATASET_NAME = 'amps_linear_algebra'

class LilaAmpsNumberTheory(Lila):
    DATASET_NAME = 'amps_number_theory'

class LilaAPPSStructured(Lila):
    DATASET_NAME = 'APPS_structured'

class LilaASDiv(Lila):
    DATASET_NAME = 'asdiv'

class LilaConalaStructured(Lila):
    DATASET_NAME = 'conala_structured'

class LilaDeepmindMathematicsAlgebra(Lila):
    DATASET_NAME = 'deepmind_mathematics_algebra'

class LilaDeepmindMathematicsBasicmath(Lila):
    DATASET_NAME = 'deepmind_mathematics_basicmath'

class LilaDeepmindMathematicsCalculus(Lila):
    DATASET_NAME = 'deepmind_mathematics_calculus'

class LilaDeepmindMathematicsMuldiv(Lila):
    DATASET_NAME = 'deepmind_mathematics_muldiv'

class LilaDeepmindMathematicsNumbertheory(Lila):
    DATASET_NAME = 'deepmind_mathematics_numbertheory'

class LilaDolphinT2Final(Lila):
    DATASET_NAME = 'dolphin_t2_final'

class LilaDrawStructured(Lila):
    DATASET_NAME = 'draw_structured'

class LilaGSM8kStructured(Lila):
    DATASET_NAME = 'GSM8k_structured'

class LilaMATHAlgebraCrowdsourced(Lila):
    DATASET_NAME = 'MATH_algebra_crowdsourced'

class LilaMATHCountingAndProbabilityCrowdsourced(Lila):
    DATASET_NAME = 'MATH_counting_and_probability_crowdsourced'

class LilaMATHIntermediateAlgebraCrowdsourced(Lila):
    DATASET_NAME = 'MATH_intermediate_algebra_crowdsourced'

class LilaMathqaGain(Lila):
    DATASET_NAME = 'mathqa_gain'

class LilaMathqaGeneral(Lila):
    DATASET_NAME = 'mathqa_general'

class LilaMathqaGeometry(Lila):
    DATASET_NAME = 'mathqa_geometry'

class LilaMathqaOther(Lila):
    DATASET_NAME = 'mathqa_other'

class LilaMathqaPhysics(Lila):
    DATASET_NAME = 'mathqa_physics'

class LilaMathqaProbability(Lila):
    DATASET_NAME = 'mathqa_probability'

class LilaMbppStructured(Lila):
    DATASET_NAME = 'mbpp_structured'

class LilaMCTacoEventDurationStructured(Lila):
    DATASET_NAME = 'MCTaco_event_duration_structured'

class LilaMCTacoEventOrderingStructured(Lila):
    DATASET_NAME = 'MCTaco_event_ordering_structured'

class LilaMCTacoEventTypicalTimeStructured(Lila):
    DATASET_NAME = 'MCTaco_event_typical_time_structured'

class LilaMCTacoFrequencyStructured(Lila):
    DATASET_NAME = 'MCTaco_frequency_structured'

class LilaMCTacoStationarityStructured(Lila):
    DATASET_NAME = 'MCTaco_stationarity_structured'

class LilaMultiArith(Lila):
    DATASET_NAME = 'multiarith'

class LilaNumersenseStructured(Lila):
    DATASET_NAME = 'Numersense_structured'

class LilaNumGLUEType1Crowdsourced(Lila):
    DATASET_NAME = 'NumGLUE_Type_1_crowdsourced'

class LilaNumGLUEType2Crowdsourced(Lila):
    DATASET_NAME = 'NumGLUE_Type_2_crowdsourced'

class LilaNumGLUEType3Crowdsourced(Lila):
    DATASET_NAME = 'NumGLUE_Type_3_crowdsourced'

class LilaNumGLUEType4Crowdsourced(Lila):
    DATASET_NAME = 'NumGLUE_Type_4_crowdsourced'

class LilaNumGLUEType5Crowdsourced(Lila):
    DATASET_NAME = 'NumGLUE_Type_5_crowdsourced'

class LilaNumGLUEType6Crowdsourced(Lila):
    DATASET_NAME = 'NumGLUE_Type_6_crowdsourced'

class LilaNumGLUEType7Crowdsourced(Lila):
    DATASET_NAME = 'NumGLUE_Type_7_crowdsourced'

class LilaNumGLUEType8Crowdsourced(Lila):
    DATASET_NAME = 'NumGLUE_Type_8_crowdsourced'

class LilaSimulEq(Lila):
    DATASET_NAME = 'simuleq'

class LilaSingleOp(Lila):
    DATASET_NAME = 'singleop'

class LilaSinglEq(Lila):
    DATASET_NAME = 'singleq'

class LilaSvampStructured(Lila):
    DATASET_NAME = 'svamp_structured'
